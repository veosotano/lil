#configure {
    name: "Pong";
    //automaticFullScreen: true; //FIXME: enable this when scaling works
    onUpdateFn: true;
}

const.f32 windowWidth: 1440f32;
const.f32 windowHeight: 900f32;

var.bool goal: false;
var.i64 goalCounter: 0;
var.i64 goalCounterMax: 50;
var.bool doesBeep: false;
var.i64 beepCounterMax: 4;
var.i64 beepCounter: 0;
const.i32 player1SoundFreq: 440i32;
const.i32 player2SoundFreq: 493i32;
const.i32 wallSoundFreq: 180i32;
const.i32 goalSoundFreq: 329i32;
const.i32 winSoundFreq: 587i32;
var.i64 player1Score: 0;
var.i64 player2Score: 0;
var.i64 player1Gamepad: 0;
var.i64 player2Gamepad: 1;
var.bool useSoloMode: false;

fn onUpdate(var.f64 deltaTime) {
    applyUserInput();
    applyUserInput2();
    var player1: @container { id: 5 };
    var player2: @container { id: 6 };
    limitPaddlePositions(player1, player2);
    var ball: @container { id: 7 };
    bounceOnEdges(ball);
    bounceOnPaddles(player1, player2, ball );
    
    checkForGoal(ball);
    if goal {
        goalCounterTick();
    }
};

fn playBeep(var.i64 howManyFrames; var.i32 freq) {
    beepCounterMax: howManyFrames;
    beepCounter: 0;
    LIL__audioDescriptor.freq: freq;
    doesBeep: true;
}

fn applyUserInput () {
    var id: 5;
    var gamepad: input.getGamepad(player1Gamepad);
    //W -- up
    // fixme: I'd like this to be:
    // if input.isKeyDown(KeyBoard.w) OR input.isKeyDown(KeyBoard.upArrow) OR input.isKeyDown(GamePad.up) { }
    // until then, we are using the platform-specific codes for now
    var.bool upIsPressed: false;
    if input.isKeyDown(126i16) { upIsPressed: true }
    if input.isKeyDown(13i16) { upIsPressed: true }
    if gamepad.y > 0.3 { upIsPressed: true }

    //S -- down
    var.bool downIsPressed: false;
    if input.isKeyDown(125i16) { downIsPressed: true }
    if input.isKeyDown(1i16) { downIsPressed: true }
    if gamepad.y < (0.0 - 0.3) { downIsPressed: true }
    if (upIsPressed) {
        app.boxVelocities[id].y +: 1.5f32;
    } else if (downIsPressed) {
        app.boxVelocities[id].y -: 1.5f32;
    } else {
        app.boxVelocities[id].y: 0f32;
    }
};
fn applyUserInput2 () {
    var id: 6;
    var gamepad: input.getGamepad(player2Gamepad);
    //K -- up
    var.bool gpUpPressed: input.isGamepadButtonDown(player2Gamepad, 4);
    var.bool gpDownPressed: input.isGamepadButtonDown(player2Gamepad, 2);
    if useSoloMode {
        var gamepad1: input.getGamepad(player1Gamepad);
        gpUpPressed: gamepad1.y2 > 0.3;
        gpUpPressed: gpUpPressed OR input.isGamepadButtonDown(player1Gamepad, 4);
        gpDownPressed: gamepad1.y2 < (0.0 - 0.3);
        gpDownPressed: gpDownPressed OR input.isGamepadButtonDown(player1Gamepad, 2);
    }
    if ( input.isKeyDown(34i16) OR (gamepad.y > 0.3) OR gpUpPressed ) {
        app.boxVelocities[id].y +: 1.5f32;

    //I -- down
    } else if ( input.isKeyDown(40i16) OR (gamepad.y < (0.0 - 0.3)) OR gpDownPressed ) {
        app.boxVelocities[id].y -: 1.5f32;
    } else {
        app.boxVelocities[id].y: 0f32;
    }
};

fn limitPaddlePositions (var.@container player1; var.@container player2) {
    if ((player1.y + player1.height) > windowHeight) {
        player1.y: windowHeight - player1.height;
        player1.velocity: @vel { x: 0f32; y: 0f32 };
    }
    if (player1.y < 0f32) {
        player1.y: 0f32;
        player1.velocity: @vel { x: 0f32; y: 0f32 };
    }
    
    if ((player2.y + player2.height) > windowHeight) {
        player2.y: windowHeight - player2.height;
        player2.velocity: @vel { x: 0f32; y: 0f32 };
    }
    if (player2.y < 0f32) {
        player2.y: 0f32;
        player2.velocity: @vel { x: 0f32; y: 0f32 };
    }
}

fn bounceOnEdges (var.@container ball) {
    var top: ball.y + ball.height;
    var bottom: ball.y;
    var left: ball.x;
    var right: ball.x + ball.width;
    // printf(`x %f y %f \n`, ball.x, bottom);
    var vel: ball.velocity;
    if (bottom <= (0f32)) {
        var.f32 yVel: vel.y;
        if (yVel < 0f32) {
            vel.y: (yVel * (-1f32)) + 1f32;
            LIL__beep();
        }
        if vel.x < 0f32 {
            vel.x -: 1f32;
        } else {
            vel.x +: 1f32;
        }
        ball.velocity: vel;
    }
    if (left <= (0f32 - 100f32)) {
        var.f32 xVel: vel.x;
        if xVel < 0f32 {
            vel.x: (xVel * (-1f32));
            ball.velocity: vel;
        }
    }
    if (top >= windowHeight) {
        var.f32 yVel: vel.y;
        if yVel > 0f32 {
            vel.y: (yVel * (-1f32)) - 1f32;
            LIL__beep();
        }
        if vel.x < 0f32 {
            vel.x -: 1f32;
        } else {
            vel.x +: 1f32;
        }
        ball.velocity: vel;
    }
    if (right >= (windowWidth + 100f32)) {
        var.f32 xVel: vel.x;
        if xVel > 0f32 {
            vel.x: (xVel * (-1f32));
            ball.velocity: vel;
        }
    }
};

fn checkForGoal (var.@container ball) {
    if goal = false {
        var left: ball.x;
        var right: ball.x + ball.width;
        if (left <= (0f32)) {
            player2Goal();
        }
        if (right >= (windowWidth)) {
            player1Goal();
        }
    }
};

fn player1Goal {
    goal: true;
    app.box2ds[0].bgColor: #F00;
    restoreBallSpeed();
    //$(@root goal).play();

    player1Score +: 1;
    if player1Score >= 6 {
        playerWin();
    } else {
        LIL__beep();
        goalCounterMax: 50;
    }
    var player1ScoreBar: @container { id: 2 };
    player1ScoreBar.width: (player1Score => f32) * 30f32;
    
};
fn player2Goal {
    goal: true;
    app.box2ds[0].bgColor: #00F;
    restoreBallSpeed();
    //$(@root goal).play();

    player2Score +: 1;
    if player2Score >= 6 {
        playerWin();
    } else {
        LIL__beep();
        goalCounterMax: 50;
    }
    var player2ScoreBar: @container { id: 4 };
    player2ScoreBar.width: (player2Score => f32) * 30f32;
};

fn newGame {
    player1Score: 0;
    player2Score: 0;
    goalCounterMax: 150;
    var player1ScoreBar: @container { id: 2 };
    player1ScoreBar.width: 0f32;
    var player2ScoreBar: @container { id: 4 };
    player2ScoreBar.width: 0f32;
}

fn playerWin {
    LIL__beep();
    newGame();
}

fn restoreBallSpeed {
    var ball: @container { id: 7 };
    var vel: ball.velocity;
    if vel.x < 0f32 {
        vel.x: (0f32 - 6f32);
    } else {
        vel.x: 6f32;
    }
    if vel.y < 0f32 {
        vel.y: (0f32 - 4f32);
    } else {
        vel.y: 4f32;
    }
    ball.velocity: vel;
}

fn goalCounterTick {
    if goalCounter < goalCounterMax {
        goalCounter +: 1;
    } else {
        goalCounter: 0;
        app.box2ds[0].bgColor: #3;
        goal: false;
    }
};

fn beepCounterTick {
    if beepCounter < beepCounterMax {
        beepCounter +: 1;
    } else {
        doesBeep: false;
        beepCounter: 0;
    }
};

fn bounceOnPaddles (var.@container player1; var.@container player2; var.@container ball) {
    var vel: ball.velocity;
    if aabbIntersects(player1, ball) {
        var.f32 xVel: vel.x;
        if xVel < 0f32 {
            vel.x: (xVel * (-1f32)) + 1f32;
            ball.velocity: vel;
            LIL__beep();
        }
    }
    
    if aabbIntersects(player2, ball) {
        var.f32 xVel: vel.x;
        if xVel > 0f32 {
            vel.x: (xVel * (-1f32)) - 1f32;
            ball.velocity: vel;
            LIL__beep();
        }
    }
};

fn aabbIntersects(var.@container a; var.@container b) => bool {
    var atlx: a.x;
    var atly: a.y + a.height;
    var abrx: a.x + a.width;
    var abry: a.y;
    var btlx: b.x;
    var btly: b.y + b.height;
    var bbrx: b.x + b.width;
    var bbry: b.y;
    
    var.bool cond1: (atlx <= bbrx);
    var.bool cond2: (abrx >= btlx);
    var.bool cond3: (atly >= bbry);
    var.bool cond4: (abry <= btly);
    return cond1 AND cond2 AND cond3 AND cond4;
}

@root {
    width: windowWidth;
    height: windowHeight;
    background: #3;
    
    #new @container player1Score {
        width: 170f32;
        height: 50f32;
        background: #0;
        
        x: 300f32;
        y: 800f32;
    }
    
    #new @container player1ScoreBar {
        width: 0f32;
        height: 30f32;
        background: #6;
        x: 310f32;
        y: 810f32;
    }
    
    #new @container player2Score {
        width: 170f32;
        height: 50f32;
        background: #0000;
        
        x: 970f32;
        y: 800f32;
    }
    
    #new @container player2ScoreBar {
        width: 0f32;
        height: 30f32;
        background: #6;
        x: 980f32;
        y: 810f32;
    }
    
    #new @container player1 {
        width: 40f32;
        height: 200f32;
        x: 10f32;
        y: (windowHeight / 2f32 ) - 100f32;
        background: #F;
    }
    #new @container player2 {
        width: 40f32;
        height: 200f32;
        x: (windowWidth - 50f32);
        y: (windowHeight / 2f32 ) - 100f32;
        background: #F;
    }
    #new @container ball {
        width: 50f32;
        height: 50f32;
        background: #F;
        x: 80f32;
        y: 400f32;
        velocity: @vel {
            x: (0f32 - 6f32);
            y: 4f32;
        };
    }

    // #new @sound goal {
    //     src: "goal.wav";
    // }
}

fn switchGamepads {
    if player1Gamepad = 0 {
        player1Gamepad: 1;
        player2Gamepad: 0;
    } else {
        player1Gamepad: 0;
        player2Gamepad: 1;
    }
}

fn toggleSoloMode {
    if useSoloMode {
        useSoloMode: false;
    } else {
        useSoloMode: true;
    }
}

@mainMenu {
    #new @menu controller {
        label: "Controller";

        #new @menuItem newGame {
            label: "New game";
            action: pointerTo(newGame);
            shortcut: "n";
        }
        #new @menuItem switchGamepads {
            label: "Switch Gamepads";
            action: pointerTo(switchGamepads);
            shortcut: "t";
        }
        #new @menuItem soloMode {
            label: "Solo mode";
            action: pointerTo(toggleSoloMode);
            shortcut: "s";
        }
    }
}
