const DEBUG: false;
const DEBUG_SHAPE_VERTICES: false;

#snippet namesSize { 256 };
#snippet namesMaxLength { 56 };
#snippet selectionSize { 256 };
#snippet entitiesSize { 2048 };
#snippet componentsSize { 32 };
#snippet actionsSize { 128 };
#snippet shapesSize { 128 };
#snippet maxPathSubdiv { 20 };
#snippet textfieldsSize { 128 };

fn onUpdate(var.f64 deltaTime) extern;
fn LIL__setWindowBgColor(var.f32 red; var.f32 green; var.f32 blue; var.f32 alpha) extern;
fn LIL__loadTexture(var.cstr path; var.i64 idx) extern;
fn LIL__unloadTexture(var.i64 idx) extern;

#import "libtess2.lil";
fn powf(f32, f32) => f32 extern;

#export {
    #needs "cstd.lil";
	#needs "events.lil";
	#needs "msg.lil";
    #needs "string.lil";

    //default entity types:
    //0: @container
    //1: @image
    //2: @sprite
	//3: @shape2d
	//4: @textfield
	//4: @label
    var.@app app: @app { selectables: []; entityCount: 0; typeCount: 5 };

    class @size {
        var.f64 width;
        var.f64 height;
    };
    class @rgb {
        var.f32 red;
        var.f32 green;
        var.f32 blue;
        var.f32 alpha;
    };
    class @vertex {
        var.f32 x;
        var.f32 y;
        var.@rgb color;
        var.f32 textureX;
        var.f32 textureY;
    };
    class @selectable {
        var.i64 nameId;
        var.i64 parentId;
        var.i64 typeId;
        var.i64 componentId;
        var.i64 resourceId;
		var.i64 actionId;
		var.i64 mouseDownActionId;
		var.i64 mouseUpActionId;
		var.i64 mouseDraggedActionId;
		var.i64 dragEndActionId;
    };
    class @pos2d {
        var.f32 x;
        var.f32 y;
    };
    class @pos {
        var.f32 x;
        var.f32 y;
        var.f32 z;
    };
    class @box2d {
        var.f32 width;
        var.f32 height;
        var.@rgb bgColor;
    };
    class @img {
        var.f32 width;
        var.f32 height;
		var.f32 textureWidth;
		var.f32 textureHeight;
		var.bool useClip;
    };
    class @resource {
        var.[1024 x i8] path;
        var.ptr(any)|null data;
    };
    class @vel
    {
        var.f32 x: 0f32;
        var.f32 y: 0f32;
        var.f32 z: 0f32;
    };
	enum.i32 ShapeType {
		moveTo,
		lineTo,
		quadCurveTo,
		curveTo
	};
	class @shapeItem {
		var.ShapeType ty;
		var.f32 x: 0;
		var.f32 y: 0;
		var.f32 x2: 0;
		var.f32 y2: 0;
		var.f32 x3: 0;
		var.f32 y3: 0;
	};
	class @shapeData {
        var.f32 width;
        var.f32 height;
        var.f32 x;
        var.f32 y;
        var.f32 z;
		var.[#paste shapesSize x @shapeItem] items: [];
		var.i64 size: 0;
        var.@rgb bgColor;
	};
    class @element {
        var.i64 id: 0;
        
        vvar.@selectable selectable;
        vvar.ptr(any)|null action;
        vvar.ptr(any)|null onMouseDown;
        vvar.ptr(any)|null onMouseUp;
        vvar.ptr(any)|null onMouseDragged;
        vvar.ptr(any)|null onDragEnd;

        fn getSelectable => @selectable {
            return app.selectables[@self.id];
        }
        fn getSelectablePointer => ptr(@selectable) {
            return pointerTo app.selectables[@self.id];
        }
        fn getName => cstr {
            var selectable: @self.selectable;
            return app.getName(selectable.nameId);
        }

		fn getAction => ptr(any)|null {
			var actionId: app.selectables[@self.id].actionId;
			if actionId >= 0 {
				return app.actions[actionId].ptr;
			} else {
				return null;
			}
		}
		fn setAction(var.ptr(any) ptr) {
			var existingAction: @self.getAction();
			if existingAction => null {
				var actionId: app.newActionId();
				app.selectables[@self.id].actionId: actionId;
				app.actions[actionId]: @action {
					elementId: @self.id;
					ptr: ptr;
				};
			}
		}
        fn getOnMouseDown => ptr(any)|null {
            var actionId: app.selectables[@self.id].mouseDownActionId;
            if actionId >= 0 {
                return app.mouseDownActions[actionId].ptr;
            } else {
                return null;
            }
        }
        fn setOnMouseDown(var.ptr(any) ptr) {
            var existingAction: @self.getOnMouseDown();
            if existingAction => null {
                var actionId: app.newMouseDownActionId();
                app.selectables[@self.id].mouseDownActionId: actionId;
                app.mouseDownActions[actionId]: @action {
                    elementId: @self.id;
                    ptr: ptr;
                };
            }
        }
        fn getOnMouseUp => ptr(any)|null {
            var actionId: app.selectables[@self.id].mouseUpActionId;
            if actionId >= 0 {
                return app.mouseUpActions[actionId].ptr;
            } else {
                return null;
            }
        }
        fn setOnMouseUp(var.ptr(any) ptr) {
            var existingAction: @self.getOnMouseUp();
            if existingAction => null {
                var actionId: app.newMouseUpActionId();
                app.selectables[@self.id].mouseUpActionId: actionId;
                app.mouseUpActions[actionId]: @action {
                    elementId: @self.id;
                    ptr: ptr;
                };
            }
        }
        fn getOnMouseDragged => ptr(any)|null {
            var actionId: app.selectables[@self.id].mouseDraggedActionId;
            if actionId >= 0 {
                return app.mouseDraggedActions[actionId].ptr;
            } else {
                return null;
            }
        }
        fn setOnMouseDragged(var.ptr(any) ptr) {
            var existingAction: @self.getOnMouseDragged();
            if existingAction => null {
                var actionId: app.newMouseDraggedActionId();
                app.selectables[@self.id].mouseDraggedActionId: actionId;
                app.mouseDraggedActions[actionId]: @action {
                    elementId: @self.id;
                    ptr: ptr;
                };
            }
        }
        fn getOnDragEnd => ptr(any)|null {
            var actionId: app.selectables[@self.id].dragEndActionId;
            if actionId >= 0 {
                return app.dragEndActions[actionId].ptr;
            } else {
                return null;
            }
        }
        fn setOnDragEnd(var.ptr(any) ptr) {
            var existingAction: @self.getOnDragEnd();
            if existingAction => null {
                var actionId: app.newDragEndActionId();
                app.selectables[@self.id].dragEndActionId: actionId;
                app.dragEndActions[actionId]: @action {
                    elementId: @self.id;
                    ptr: ptr;
                };
            }
        }
    };
    class @sel {
        var.[#paste selectionSize x @element] items: [];
        var.i64 size: 0;
    };
	class @action
	{
		var.i64 elementId;
		var.ptr(any) ptr;
	}
    class @textfieldData {
        var.@rgb bgColor;
        var.ptr(any) data;
        var.ptr(any)|null onChange;
        var.f32 width: 0;
        var.f32 height: 0;
        var.f32 x: 0;
        var.f32 y: 0;
    }
    class @container
    {
        //this class MUST only be an i64
        //do not add any more vars
        #expand var.@element super: @element { };

        //public interface
        vvar.i64 componentId;
        vvar.f32 width;
        vvar.f32 height;
        vvar.@rgb background;
        vvar.f32 x;
        vvar.f32 y;
        vvar.f32 z;
        vvar.@vel velocity;
        
        fn getComponentId => i64 {
            return app.selectables[@self.id].componentId;
        }
        
        fn initialize(var.cstr name; var.i64 parentId: 0) => i64 {
            var componentId: app.newBox();
			var id: app.newElement(name, parentId, 0, componentId);
			@self.id: id;
            return id;
        }

        fn setWidth(var.f32 value) {
            app.box2ds[@self.componentId].width: value;
        };
        fn getWidth {
            return app.box2ds[@self.componentId].width;
        };
        fn setHeight(var.f32 value) {
            app.box2ds[@self.componentId].height: value;
        };
        fn getHeight {
            return app.box2ds[@self.componentId].height;
        };
        fn setBackground(var.@rgb value) {
            app.box2ds[@self.componentId].bgColor: value;
        };
        fn getBackground {
            return app.box2ds[@self.componentId].bgColor;
        };
        fn getBackgroundPointer {
            return pointerTo app.box2ds[@self.componentId].bgColor;
        };
        fn setX(var.f32 value) {
            app.boxPositions[@self.componentId].x: value;
        }
        fn getX() => f32 {
            return app.boxPositions[@self.componentId].x;
        };
        fn setY(var.f32 value) {
            app.boxPositions[@self.componentId].y: value;
        };
        fn getY() => f32 {
            return app.boxPositions[@self.componentId].y;
        };
        fn setZ(var.f32 value) {
            app.boxPositions[@self.componentId].z: value;
        };
        fn getZ() => f32 {
            return app.boxPositions[@self.componentId].z;
        };
        fn setVelocity(var.@vel value) {
            app.boxVelocities[@self.componentId]: value;
        };
        fn getVelocity() => @vel {
            return app.boxVelocities[@self.componentId];
        }
        fn getVelocityPointer() => ptr(@vel) {
            return pointerTo app.boxVelocities[@self.componentId];
        }
    };

    class @image {
        //this class MUST only be an i64
        //do not add any more vars
        #expand var.@element super: @element { };

        //public interface
        vvar.i64 componentId;
        vvar.f32 width;
        vvar.f32 height;
        vvar.f32 x;
        vvar.f32 y;
        vvar.f32 z;
        vvar.@vel velocity;
        //fixme: should be =>cstr
        #resource vvar.ptr(@string)=>ptr(i8) src;

        fn getComponentId => i64 {
            return app.selectables[@self.id].componentId;
        }

        fn initialize(var.cstr name; var.i64 parentId: 0) => i64 {
			#if DEBUG {
				puts `created image!`;
			}
            var componentId: app.newImg();
            @self.id: app.newElement(name, parentId, 1, componentId);
            return @self.id;
        }

        fn setWidth(var.f32 value) {
            app.imgs[@self.componentId].width: value;
        };
        fn getWidth {
            return app.imgs[@self.componentId].width;
        };
        fn setHeight(var.f32 value) {
            app.imgs[@self.componentId].height: value;
        };
        fn getHeight {
            return app.imgs[@self.componentId].height;
        };
        fn setX(var.f32 value) {
            app.imgPositions[@self.componentId].x: value;
        }
        fn getX() => f32 {
            return app.imgPositions[@self.componentId].x;
        };
        fn setY(var.f32 value) {
            app.imgPositions[@self.componentId].y: value;
        };
        fn getY() => f32 {
            return app.imgPositions[@self.componentId].y;
        };
        fn setZ(var.f32 value) {
            app.imgPositions[@self.componentId].z: value;
        };
        fn getZ() => f32 {
            return app.imgPositions[@self.componentId].z;
        };
        fn setVelocity(var.@vel value) {
            app.imgVelocities[@self.componentId]: value;
        };
        fn getVelocity() => @vel {
            return app.imgVelocities[@self.componentId];
        }
        fn getVelocityPointer() => ptr(@vel) {
            return pointerTo app.imgVelocities[@self.componentId];
        }

        fn getSrc() => cstr {
            var resourceId: app.selectables[@self.id].resourceId;
            return pointerTo(app.resources[resourceId].path) => ptr(i8);
        }
        fn setSrc(var.ptr(@string) value) {
            var resourceId: app.selectables[@self.id].resourceId;
            if resourceId < 0 {
                app.selectables[@self.id].resourceId: app.newResource();
            }
            memcpy(@self.src, value.cstr(), value.length);
        }

		fn load(var.ptr(@string) value) {
            @self.setSrc(value);
			LIL__loadTexture(value.cstr(), app.selectables[@self.id].resourceId);
		}
    };
    
    class @sprite {
        //this class MUST only be an i64
        //do not add any more vars
        #expand var.@image super: @image { };
        
        vvar.f32 clipX;
        vvar.f32 clipY;
        
        fn initialize(var.cstr name; var.i64 parentId: 0) => i64 {
			#if DEBUG {
				puts `created sprite!`;
			}
            var componentId: app.newImg();
            @self.id: app.newElement(name, parentId, 2, componentId);
			app.imgs[componentId].useClip: true;
            return @self.id;
        }
        
        fn setClipX(var.f32 value) {
            app.imgClips[@self.componentId].x: value;
        }
        fn getClipX() => f32 {
            return app.imgClips[@self.componentId].x;
        };
        fn setClipY(var.f32 value) {
            app.imgClips[@self.componentId].y: value;
        };
        fn getClipY() => f32 {
            return app.imgClips[@self.componentId].y;
        };
    }
	
	class @shape2d {
        //this class MUST only be an i64
        //do not add any more vars
        #expand var.@element super: @element { };
		
        //public interface
        vvar.i64 componentId;
        vvar.f32 width;
        vvar.f32 height;
        vvar.f32 x;
        vvar.f32 y;
        vvar.f32 z;
        vvar.@rgb background;

        fn getComponentId => i64 {
            return app.selectables[@self.id].componentId;
        }

        fn initialize(var.cstr name; var.i64 parentId: 0) => i64 {
			#if DEBUG {
				puts `created shape!`;
			}
            var componentId: app.newShape();
            @self.id: app.newElement(name, parentId, 3, componentId);
            return @self.id;
        }

        fn setWidth(var.f32 value) {
            app.shapes[@self.componentId].width: value;
        };
        fn getWidth {
            return app.shapes[@self.componentId].width;
        };
        fn setHeight(var.f32 value) {
            app.shapes[@self.componentId].height: value;
        };
        fn getHeight {
            return app.shapes[@self.componentId].height;
        };
        fn setX(var.f32 value) {
            app.shapes[@self.componentId].x: value;
        }
        fn getX() => f32 {
            return app.shapes[@self.componentId].x;
        };
        fn setY(var.f32 value) {
            app.shapes[@self.componentId].y: value;
        };
        fn getY() => f32 {
            return app.shapes[@self.componentId].y;
        };
        fn setZ(var.f32 value) {
            app.shapes[@self.componentId].z: value;
        };
        fn getZ() => f32 {
            return app.shapes[@self.componentId].z;
        };
        fn setBackground(var.@rgb value) {
            app.shapes[@self.componentId].bgColor: value;
        };
        fn getBackground {
            return app.shapes[@self.componentId].bgColor;
        };
        fn getBackgroundPointer {
            return pointerTo app.shapes[@self.componentId].bgColor;
        };
		
		fn moveTo(var.f32 x; var.f32 y) {
			var shape: pointerTo app.shapes[@self.componentId];
			var size: shape.size;
			var newItem: @shapeItem {
				ty: ShapeType.moveTo;
				x: x;
				y: y;
			};
			shape.items[size]: newItem;
			shape.size +: 1;
			#if DEBUG {
				printf(`created moveTo with x:%f and y:%f\n`, x, y);
			}
		}
		fn lineTo(var.f32 x; var.f32 y) {
			var shape: pointerTo app.shapes[@self.componentId];
			var size: shape.size;
			var newItem: @shapeItem {
				ty: ShapeType.lineTo;
				x: x;
				y: y;
			};
			shape.items[size]: newItem;
			shape.size +: 1;
			#if DEBUG {
				printf(`created lineTo with x:%f and y:%f\n`, x, y);
			}
		}
		fn quadCurveTo(var.f32 ctlPtX; var.f32 ctlPtY; var.f32 toPtX; var.f32 toPtY) {
			var shape: pointerTo app.shapes[@self.componentId];
			var size: shape.size;
			var newItem: @shapeItem {
				ty: ShapeType.quadCurveTo;
				x: ctlPtX;
				y: ctlPtY;
				x2: toPtX;
				y2: toPtY;
			};
			shape.items[size]: newItem;
			shape.size +: 1;
			#if DEBUG {
				printf(`created quadCurveTo with controlPointX: %f, controlPointY: %, toPointX:%f and toPointY:%f\n`, ctlPtX, ctlPtY, toPtX, toPtY);
			}
		}
		fn curveTo(var.f32 ctlPt1X; var.f32 ctlPt1Y; var.f32 ctlPt2X; var.f32 ctlPt2Y; var.f32 toPtX; var.f32 toPtY) {
			var shape: pointerTo app.shapes[@self.componentId];
			var size: shape.size;
			var newItem: @shapeItem {
				ty: ShapeType.curveTo;
				x: ctlPt1X;
				y: ctlPt1Y;
				x2: ctlPt2X;
				y2: ctlPt2Y;
				x3: toPtX;
				y3: toPtY;
			};
			shape.items[size]: newItem;
			shape.size +: 1;
			#if DEBUG {
				printf(`created curveTo with controlPoint1X: %f, controlPoint1Y: %, controlPoint2X: %f, controlPoint2Y: %, toPointX:%f and toPointY:%f\n`, ctlPt1X, ctlPt1Y, ctlPt2X, ctlPt2Y, toPtX, toPtY);
			}
		}
	}
	
	fn LIL__mouseClickListener(var.ptr(any) data) {
		var.ptr(@mouseEvent) event: data;
		var mouseX: event.x => f32;
		var mouseY: event.y => f32;
		#if DEBUG {
			printf(`mouse listener: x:%lf y:%lf\n`, mouseX, mouseY);	
		}
		for (var.i64 i: 0; i<app.actionCount; i +: 1) {
			var action: app.actions[i];
			var elem: app.selectables[action.elementId];
			if LIL__mouseIntersectionTest(elem.typeId, elem.componentId, mouseX, mouseY) {
				var callback: action.ptr => ptr(fn(ptr(any)));
				callback(data);
			}
		}
	}
    
    fn LIL__mouseDownListener(var.ptr(any) data) {
        var.ptr(@mouseEvent) event: data;
        var mouseX: event.x => f32;
        var mouseY: event.y => f32;
        for (var.i64 i: 0; i<app.mouseDownActionCount; i +: 1) {
            var action: app.mouseDownActions[i];
            var id: action.elementId;
            var elem: app.selectables[id];
            if LIL__mouseIntersectionTest(elem.typeId, elem.componentId, mouseX, mouseY) {
                app.dragTargetId: id;
                app.dragOrigin: @pos2d { x: mouseX; y: mouseY };
                var callback: action.ptr => ptr(fn(ptr(any)));
                callback(data);
            }
        }
    }
    
    fn LIL__mouseDraggedListener(var.ptr(any) data) {
        var.ptr(@mouseEvent) event: data;
        if !app.dragHasSession {
            if (
                (fabsf(event.x - app.dragOrigin.x) >= app.dragMinDistance)
                OR (fabsf(event.y - app.dragOrigin.y) >= app.dragMinDistance)
            ) {
                app.dragHasSession: true;
            } else {
                app.dragHasSession: false;
            }
        }
        
        if app.dragHasSession {
            for (var.i64 i: 0; i<app.mouseDraggedActionCount; i +: 1) {
                var action: app.mouseDraggedActions[i];
                var id: action.elementId;
                if id = app.dragTargetId {
                    var callback: action.ptr => ptr(fn(ptr(any)));
                    callback(data);
                }
            }
        }
    }
    
    fn LIL__mouseUpListener(var.ptr(any) data) {
        //send the mouse up events
        var.ptr(@mouseEvent) event: data;
        var mouseX: event.x => f32;
        var mouseY: event.y => f32;
        for (var.i64 i: 0; i<app.mouseUpActionCount; i +: 1) {
            var action: app.mouseUpActions[i];
            var id: action.elementId;
            var elem: app.selectables[id];
            if LIL__mouseIntersectionTest(elem.typeId, elem.componentId, mouseX, mouseY) {
                var callback: action.ptr => ptr(fn(ptr(any)));
                callback(data);
            }
        }

        if app.dragHasSession {
            //send the drag end event
            for (var.i64 i: 0; i<app.dragEndActionCount; i +: 1) {
                var action: app.dragEndActions[i];
                var id: action.elementId;
                if id = app.dragTargetId {
                    var callback: action.ptr => ptr(fn(ptr(any)));
                    callback(data);
                }
            }
            app.dragHasSession: false;
        }
        app.dragTargetId: 0;
    }
    
    fn LIL__mouseIntersectionTest(var.i64 typeId; var.i64 componentId; var.f32 mouseX; var.f32 mouseY) => bool {
        if typeId = 0 {
            var pos: app.boxPositions[componentId];
            var box: app.box2ds[componentId];
            return  (mouseX >= pos.x) AND (mouseX < (pos.x + box.width)) AND (mouseY >= pos.y) AND (mouseY < (pos.y + box.height));
        } else if ((typeId = 1) OR (typeId = 2)) {
            var pos: app.imgPositions[componentId];
            var img: app.imgs[componentId];
            var width: img.width;
            var height: img.height;
            if width = 0 { width: img.textureWidth }
            if height = 0 { height: img.textureHeight }
            return (mouseX >= pos.x) AND (mouseX < (pos.x + width)) AND (mouseY >= pos.y) AND (mouseY < (pos.y + height));
        } else if typeId = 3 {
            var shape: app.shapes[componentId];
            var x: shape.x;
            var y: shape.y;
            var width: shape.width;
            var height: shape.height;
            return  (mouseX >= x) AND (mouseX < (x + width)) AND (mouseY >= y) AND (mouseY < (y + height));
        }
        return false;
    }
    
    fn LIL__intersectionTest(var.@container|@image item; var.f32 testX; var.f32 testY) => bool {
        if item => @container {
            var componentId: item.componentId;
            var pos: app.boxPositions[componentId];
            var box: app.box2ds[componentId];
            return  (testX >= pos.x) AND (testX < (pos.x + box.width)) AND (testY >= pos.y) AND (testY < (pos.y + box.height));
        } else if item => @image {
            var componentId: item.componentId;
            var pos: app.imgPositions[componentId];
            var img: app.imgs[componentId];
            var width: img.width;
            var height: img.height;
            if width = 0 { width: img.textureWidth }
            if height = 0 { height: img.textureHeight }
            return (testX >= pos.x) AND (testX < (pos.x + width)) AND (testY >= pos.y) AND (testY < (pos.y + height));
        }
    }

    class @app {
        var.[#paste entitiesSize x @selectable] selectables: [];
        var.i64 entityCount: 0;
        //boxes
        var.[#paste entitiesSize x @pos] boxPositions: [];
        var.[#paste entitiesSize x @vel] boxVelocities: [];
        var.[#paste entitiesSize x @box2d] box2ds: [];
        var.i64 boxCount: 0;
        //imgs
        var.[#paste entitiesSize x @pos] imgPositions: [];
        var.[#paste entitiesSize x @vel] imgVelocities: [];
        var.[#paste entitiesSize x @pos2d] imgClips: [];
        var.[#paste entitiesSize x @img] imgs: [];
        var.i64 imgCount: 0;
		//shapes
		var.[#paste entitiesSize x @shapeData] shapes: [];
        var.i64 shapesCount: 0;
        //names
        var.[#paste namesSize x [#paste namesMaxLength x i8]] names: [];
        var.i64 nameCount: 0;
        var.i64 typeCount: 0;
		//resources
        var.[#paste entitiesSize x @resource] resources: [];
        var.i64 resourceCount: 0;
		//actions
		var.[#paste actionsSize x @action] actions: [];
		var.i64 actionCount: 0;
		var.[#paste actionsSize x @action] mouseDownActions: [];
		var.i64 mouseDownActionCount: 0;
        var.[#paste actionsSize x @action] mouseUpActions: [];
        var.i64 mouseUpActionCount: 0;
		var.[#paste actionsSize x @action] mouseDraggedActions: [];
		var.i64 mouseDraggedActionCount: 0;
        var.[#paste actionsSize x @action] dragEndActions: [];
        var.i64 dragEndActionCount: 0;
        var.i64 dragTargetId: 0;
        var.@pos2d dragOrigin: @pos2d { x: 0; y: 0 };
        var.f32 dragMinDistance: 3.0;
        var.bool dragHasSession: false;
        //textfields
        var.[#paste textfieldsSize x @textfieldData] textfields: [];
        var.i64 textfieldCount: 0;
		
		fn initialize {
            //get root's background color
			//fixme: use selection system instead of hardcoded to 0
            var bgColor: app.box2ds[0].bgColor;
            LIL__setWindowBgColor(bgColor.red, bgColor.green, bgColor.blue, bgColor.alpha);
			//install the mouse listeners
			msgSub(`onClick`, LIL__mouseClickListener);
            msgSub(`onMouseDown`, LIL__mouseDownListener);
            msgSub(`onMouseDragged`, LIL__mouseDraggedListener);
            msgSub(`onMouseUp`, LIL__mouseUpListener);
		};

        fn newEntity => i64 {
            #if DEBUG {
                puts `Creating new entity`;
            }
            var currentCount: @self.entityCount;
            @self.entityCount +: 1;
            return currentCount;
        };
        fn newType => i64 {
            #if DEBUG {
                puts `Creating new type`;
            }
            var currentCount: @self.typeCount;
            @self.typeCount +: 1;
            return currentCount;
        };
        fn registerName(var.cstr name){
            #if DEBUG {
                printf(`Register name %s\n`, name);
            }
            var.bool found: false;
            var.i64 existingId: 0;
            #if DEBUG {
                printf(`Name count %li\n`, @self.nameCount);
            }
            for (var.i64 i:0; i<@self.nameCount; i+:1) {
                #if DEBUG {
                    printf(`Checking id %li\n`, i);
                    printf(`name %li is %s\n`, i, pointerTo(@self.names[i]) => ptr(i8));
                }
                if (strncmp(name, (pointerTo(@self.names[i]) => ptr(i8)), #paste namesMaxLength) = 0i32) {
                    found: true;
                    existingId: i;
                    //break;
                }
            }
            if found {
                return existingId;
            } else {
                var currentCount: @self.nameCount;
                memcpy(
                    dst: pointerTo(@self.names[currentCount]) => ptr(i8);
                    src: name;
                    len: strnlen(name, #paste namesMaxLength)
                );
                #if DEBUG {
                    printf(`name %li is now %s\n`, currentCount, pointerTo(@self.names[currentCount]) => ptr(i8));
                }
                @self.nameCount +: 1;
                return currentCount;
            }
        };
        fn getName(var.i64 id) => cstr {
            return pointerTo(@self.names[id]) => cstr;
        };
        fn selectByName(var.i64 parentId; var.i64 nameId)=>@sel {
            var ret: @sel { };
            for(var.i64 i: 0; i<@self.entityCount; i+:1) {
                var item: pointerTo @self.selectables[i];
                if item.parentId = parentId {
                    if item.nameId = nameId {
                        ret.items[ret.size]: @element { id: i };
                        ret.size +: 1;
                    }
                }
            }
            return ret;
        };
        fn setSelectable(var.i64 id; var.@selectable value) {
            #if DEBUG {
                printf(`Setting selectable with name %s for id %li with type %li\n`, @self.getName(value.nameId), id, value.typeId);
            }
            @self.selectables[id]: value;
        };
        fn newElement(var.cstr name; var.i64 parentId: 0; var.i64 typeId: 0; var.i64 componentId: 0)=>i64 {
            #if DEBUG {
                puts `Creating new element`;
            }
            var.i64 id: @self.newEntity();
            var.i64 nameId: @self.registerName(name);
            @self.setSelectable(id, @selectable {
                nameId: nameId;
                parentId: parentId;
                typeId: typeId;
                componentId: componentId;
				resourceId: (0-1);
				actionId: (0-1);
                mouseDownActionId: (0-1);
                mouseDraggedActionId: (0-1);
                mouseUpActionId: (0-1);
                dragEndActionId: (0-1);
            });
            return id;
        };
        fn newBox => i64 {
            var currentCount: @self.boxCount;
            @self.boxCount +: 1;
            return currentCount;
        };
        fn newImg => i64 {
            var currentCount: @self.imgCount;
            @self.imgCount +: 1;
            return currentCount;
        };
        fn newShape => i64 {
            var currentCount: @self.shapesCount;
            @self.shapesCount +: 1;
            return currentCount;
        };
        fn newResource => i64 {
            var currentCount: @self.resourceCount;
            @self.resourceCount +: 1;
            return currentCount;
        }
		fn newActionId => i64 {
            #if DEBUG {
                puts `Creating new action id`;
            }
            var currentCount: @self.actionCount;
            @self.actionCount +: 1;
            return currentCount;
		}
        fn newTextfield => i64 {
            var currentCount: @self.textfieldCount;
            @self.textfieldCount +: 1;
            return currentCount;
        };
        fn newMouseDownActionId => i64 {
            var currentCount: @self.mouseDownActionCount;
            @self.mouseDownActionCount +: 1;
            return currentCount;
        }
        fn newMouseUpActionId => i64 {
            var currentCount: @self.mouseUpActionCount;
            @self.mouseUpActionCount +: 1;
            return currentCount;
        }
        fn newMouseDraggedActionId => i64 {
            var currentCount: @self.mouseDraggedActionCount;
            @self.mouseDraggedActionCount +: 1;
            return currentCount;
        }
        fn newDragEndActionId => i64 {
            var currentCount: @self.dragEndActionCount;
            @self.dragEndActionCount +: 1;
            return currentCount;
        }
    };

    fn LIL__nameToNameId(var.cstr name) => i64 {
        return app.registerName(name);
    };

    fn LIL__selectByName(var.i64 nameId; var.i64 parentId) => @sel {
        var ret: @sel { };
        for(var.i64 i:0; i<app.entityCount; i+:1){
            var selectable: app.selectables[i];
            if (selectable.parentId = parentId) {
                if(selectable.nameId = nameId){
                    ret.items[ret.size]: @element { id: i };
                    ret.size +: 1;
                }
            }
        }
        return ret;
    };
    
    fn LIL__getResourceCount => i64 {
        return app.resourceCount;
    }
    
    fn LIL__getResorceById(var.i64 id) => ptr(@resource) {
        return pointerTo app.resources[id];
    }
    
    fn LIL__movementSystem(var.f64 deltaTime) {
        var.f64 dt: deltaTime * 60;
        for (var.i64 i:0; i<app.boxCount; i+:1) {
            app.boxPositions[i].x +: ((app.boxVelocities[i].x => f64) * dt) => f32;
            app.boxPositions[i].y +: ((app.boxVelocities[i].y => f64) * dt) => f32;
            app.boxPositions[i].z +: ((app.boxVelocities[i].z => f64) * dt) => f32;
        }
        for (var.i64 i:0; i<app.imgCount; i+:1) {
            app.imgPositions[i].x +: ((app.imgVelocities[i].x => f64) * dt) => f32;
            app.imgPositions[i].y +: ((app.imgVelocities[i].y => f64) * dt) => f32;
            app.imgPositions[i].z +: ((app.imgVelocities[i].z => f64) * dt) => f32;
        }
    };

    fn LIL__runSystems(var.f64 deltaTime) {
        LIL__movementSystem(deltaTime);
    };

    fn LIL__nextFrame(var.ptr(any) vertexBuffer; var.ptr(i64) vertexCount; var.f64 deltaTime) {
        #if #getConfig(onUpdateFn) {
            onUpdate(deltaTime);
        }
        LIL__runSystems(deltaTime);
    };
	
	fn LIL__setTextureSize(var.i64 imgId; var.f32 width; var.f32 height) {
		app.imgs[imgId].textureWidth: width;
		app.imgs[imgId].textureHeight: height;
	};
    
    fn LIL__makeBoxVertices(var.ptr(any) vertexBuffer; var.ptr(i64) vertexCount) {

        var.[1000 x @vertex] vertices: [];
        for (var.i64 i:0; i<app.boxCount; i+:1) {

            var box: app.box2ds[i];
            var pos: app.boxPositions[i];
            var color: box.bgColor;

            var.i64 triIdx: i*6;

            vertices[triIdx]: @vertex {
                x: pos.x + box.width;
                y: pos.y;
                color: color;
                textureX: 1f32;
                textureY: 1f32;
            };

            vertices[triIdx+1]: @vertex {
                x: pos.x;
                y: pos.y;
                color: color;
                textureX: 0f32;
                textureY: 1f32;
            };

            vertices[triIdx+2]: @vertex {
                x: pos.x;
                y: pos.y + box.height;
                color: color;
                textureX: 0f32;
                textureY: 0f32;
            };


            vertices[triIdx+3]: @vertex {
                x: pos.x + box.width;
                y: pos.y;
                color: color;
                textureX: 1f32;
                textureY: 1f32;
            };

            vertices[triIdx+4]: @vertex {
                x: pos.x;
                y: pos.y + box.height;
                color: color;
                textureX: 0f32;
                textureY: 0f32;
            };

            vertices[triIdx+5]: @vertex {
                x: pos.x + box.width;
                y: pos.y + box.height;
                color: color;
                textureX: 1f32;
                textureY: 0f32;
            };
        }

        var.i64 bufferSize: (sizeOf(type @vertex) * 6 * app.boxCount);
        memcpy (vertexBuffer, pointerTo(vertices), bufferSize);
        vertexCount: app.boxCount * 6;
    }
    
    fn LIL__makeTextureVertices(var.ptr(any) vertexBuffer; var.ptr(i64) vertexCount) {
        var.[1000 x @vertex] vertices: [];
		var color: #F00;
        for (var.i64 i:0; i<app.imgCount; i+:1) {

            var img: app.imgs[i];
            var pos: app.imgPositions[i];
            var clip: app.imgClips[i];
            var.i64 triIdx: i*6;
			
			var.f32 minX;
			var.f32 maxX;
			var.f32 minY;
			var.f32 maxY;
			
			var.f32 width: img.width;
			var.f32 height: img.height;
			if width = 0 {
				width: img.textureWidth;
			}
			if height = 0 {
				height: img.textureHeight;
			}
			
			
			if img.useClip {
				minX: clip.x / img.textureWidth;
				maxX: (clip.x + width) / img.textureWidth;
				minY: clip.y / img.textureHeight;
				maxY: (clip.y + height) / img.textureHeight;
			} else {
				minX: 0;
				maxX: 1;
				minY: 0;
				maxY: 1;
			}
            
            vertices[triIdx]: @vertex {
                x: pos.x + width;
                y: pos.y;
                color: color;
                textureX: maxX;
                textureY: maxY;
            };

            vertices[triIdx+1]: @vertex {
                x: pos.x;
                y: pos.y;
                color: color;
                textureX: minX;
                textureY: maxY;
            };

            vertices[triIdx+2]: @vertex {
                x: pos.x;
                y: pos.y + height;
                color: color;
                textureX: minX;
                textureY: minY;
            };


            vertices[triIdx+3]: @vertex {
                x: pos.x + width;
                y: pos.y;
                color: color;
                textureX: maxX;
                textureY: maxY;
            };

            vertices[triIdx+4]: @vertex {
                x: pos.x;
                y: pos.y + height;
                color: color;
                textureX: minX;
                textureY: minY;
            };

            vertices[triIdx+5]: @vertex {
                x: pos.x + width;
                y: pos.y + height;
                color: color;
                textureX: maxX;
                textureY: minY;
            };
        }

        var.i64 bufferSize: (sizeOf(type @vertex) * 6 * app.imgCount);
        memcpy (vertexBuffer, pointerTo(vertices), bufferSize);
        vertexCount: app.imgCount * 6;
    }

	fn LIL__makeShapeVertices(var.ptr(any) vertexBuffer; var.ptr(i64) vertexCount; var.ptr(any) indexBuffer; var.ptr(i64) indexCount) {
		var.[1000 x @pos2d] subpaths: [];
		var.[300 x i64] subpathIndices: [];
		var.i64 pathElemsCount: 0;
		var.i64 subpathCount: 0;

		var.[1000 x @vertex] theVertices: [];
		var.[1000 x i32] theIndices: [];

		var.ptr(@TESStesselator) tess: tessNewTess(null);
		
		var.i64 vtxCount: 0;
		var.i64 idxCount: 0;

		for (var.i64 i:0; i<app.shapesCount; i+:1) {
			#if DEBUG_SHAPE_VERTICES {
				printf(`tessellating shape %li\n`, i);
			}
			pathElemsCount: 0;
			subpathCount: 0;
			
			var shape: pointerTo app.shapes[i];
			for (var.i64 j:0; j<shape.size; j+:1) {
				var shapeItem: shape.items[j];
				#if DEBUG_SHAPE_VERTICES {
					printf(`shape item %li has type %i\n`, j, shapeItem.ty);
				}
				if shapeItem.ty = ShapeType.moveTo
				{
					subpathIndices[subpathCount]: pathElemsCount;
					subpathCount +: 1;

					subpaths[pathElemsCount]: @pos2d {
						x: shapeItem.x;
						y: shapeItem.y;
					};
					pathElemsCount +: 1;
				}
				else if shapeItem.ty = ShapeType.lineTo
				{
					subpaths[pathElemsCount]: @pos2d {
						x: shapeItem.x;
						y: shapeItem.y;
					};
					pathElemsCount +: 1;
				}
				else if shapeItem.ty = ShapeType.quadCurveTo
				{
					//convert to line segments using adaptive subdivision
					var fromPoint: subpaths[pathElemsCount - 1];
					var toPoint: @pos2d {
						x: shapeItem.x2;
						y: shapeItem.y2;
					};
					var controlPoint: @pos2d {
						x: shapeItem.x;
						y: shapeItem.y;
					};
					var.f32 maxTolerance: 0.2;
					var.f32 t: 0;
					var.f32 candidateT: 0.5;
					var.@pos2d currentPoint: fromPoint;

					loop {
						var.i32 subdivs: 1;
						var.f32  err: 999.0;
						var.@pos2d candidatePoint: currentPoint;
						if (t + 0.5) > 1.0 {
							candidateT: 1.0;
						} else {
							candidateT: t + 0.5;
						}
						loop {
							candidatePoint: LIL__evalQuadCurve(fromPoint, controlPoint, toPoint, candidateT);
							var.f32 midT: (t + candidateT) / 2;
							var.@pos2d midCurve: LIL__evalQuadCurve(fromPoint, controlPoint, toPoint, midT);
							var.@pos2d midSeg: LIL__lerpPoints(currentPoint, candidatePoint, 0.5);
							err: powf(midSeg.x - midCurve.x, 2) + powf(midSeg.y - midCurve.y, 2);

							if (err > maxTolerance) {
								candidateT: t + (0.5 * (candidateT - t));
								subdivs +: 1;
								if (subdivs < #paste maxPathSubdiv) {
									repeat;
								}
							}
						}

						t: candidateT;
						currentPoint: candidatePoint;

						subpaths[pathElemsCount]:currentPoint;
						pathElemsCount +: 1;

						if (t < 1.0) {
							repeat;
						}
					}
				} else if shapeItem.ty = ShapeType.curveTo
				{
					//convert to line segments using adaptive subdivision
					var fromPoint: subpaths[pathElemsCount - 1];
					var toPoint: @pos2d {
						x: shapeItem.x3;
						y: shapeItem.y3;
					};
					var controlPoint1: @pos2d {
						x: shapeItem.x;
						y: shapeItem.y;
					};
					var controlPoint2: @pos2d {
						x: shapeItem.x2;
						y: shapeItem.y2;
					};
					var.f32 maxTolerance: 0.2;
					var.f32 t: 0;
					var.f32 candidateT: 0.5;
					var.@pos2d currentPoint: fromPoint;

					loop {
						var.i32 subdivs: 1;
						var.f32  err: 999.0;
						var.@pos2d candidatePoint: currentPoint;
						if (t + 0.5) > 1.0 {
							candidateT: 1.0;
						} else {
							candidateT: t + 0.5;
						}

						loop {
							candidatePoint: LIL__evalCubicCurve(fromPoint, controlPoint1, controlPoint2, toPoint, candidateT);
							var.f32 midT: (t + candidateT) / 2;
							var.@pos2d midCurve: LIL__evalCubicCurve(fromPoint, controlPoint1, controlPoint2, toPoint, midT);
							var.@pos2d midSeg: LIL__lerpPoints(currentPoint, candidatePoint, 0.5);
							err: powf(midSeg.x - midCurve.x, 2) + powf(midSeg.y - midCurve.y, 2);

							if (err > maxTolerance) {
								candidateT: t + (0.5 * (candidateT - t));
								subdivs +: 1;
								if (subdivs < #paste maxPathSubdiv) {
									repeat;
								}
							}
						}

						t: candidateT;
						currentPoint: candidatePoint;

						subpaths[pathElemsCount]:currentPoint;
						pathElemsCount +: 1;

						if (t < 1.0) {
							repeat;
						}
					}
				}
			}

			for (var.i64 j:0; j<subpathCount; j+:1) {
				var.i64 from: subpathIndices[j];
				var.i64 to;
				if j < (subpathCount - 1) {
					to: subpathIndices[j+1];
				} else {
					to: pathElemsCount;
				}
				tessAddContour(
					tess: tess;
					size: 2;
					vertices: (pointerTo(subpaths) => ptr(@pos2d)) + from;
					stride: sizeOf(type @pos2d) => i32;
					numVertices: (to - from) => i32
				);
			}
		
			var tessResult: tessTesselate(
				tess: tess;
				windingRule: TESSwindingRule.odd;
				elementType: TESSelementType.polygons;
				polySize: 3;
				vertexSize: 2
			);
			#if DEBUG_SHAPE_VERTICES {
				printf(`tessellation result is %i\n`, tessResult);
			}
		
			var.i64 tessVertexCount: tessGetVertexCount(tess);
			var.ptr(f32) tessVertices: tessGetVertices(tess);
			var.i64 tessElemCount: tessGetElementCount(tess);
			var.ptr(i32) tessIndices: tessGetElements(tess);

			for (var.i64 k:0; k<tessVertexCount; k+:1) {
				theVertices[vtxCount + k]: @vertex {
					x: valueOf(tessVertices + (k*2)) + shape.x;
					y: valueOf(tessVertices + ((k*2)+1)) + shape.y;
					color: shape.bgColor;
					textureX: 0;
					textureY: 0;
				};
			}
			
			var.i64 tessIndexCount: tessElemCount * 3;
			#if DEBUG_SHAPE_VERTICES {
				printf(`copying %li indices to %li\n`, tessIndexCount, idxCount);
			}
			for (var.i64 k:0; k<tessIndexCount; k+:1) {
				theIndices[idxCount + k]: valueOf(tessIndices + k) + vtxCount;
			}
			vtxCount +: tessVertexCount;
			idxCount +: tessIndexCount;
		}

		tessDeleteTess(tess);
		
		#if DEBUG_SHAPE_VERTICES {
			puts `vertices:`;
			for (var.i64 i:0; i<vtxCount; i+:1) {
				var vtx: theVertices[i];
				printf(`%f %f ,`, vtx.x, vtx.y);
			}
			printf(`\n`);

			puts `indices:`;
			for (var.i64 i:0; i<idxCount; i+:1) {
				var idx: theIndices[i];
				printf(`%li, `, idx);
			}
			printf(`\n`);
		}

		var.i64 bufferSize: (sizeOf(type @vertex) * vtxCount);
		#if DEBUG_SHAPE_VERTICES {
			printf(`copying %li vertices to buffer\n`, vtxCount);
		}
    	memcpy (vertexBuffer, pointerTo(theVertices), bufferSize);
		vertexCount: vtxCount;
		indexCount: idxCount;
		memcpy (indexBuffer, pointerTo(theIndices), (sizeOf(type i32) * idxCount));
		#if DEBUG_SHAPE_VERTICES {
			printf(`copying %li indices to index buffer\n`, idxCount);
			puts `=====`;
		}
	}
	
	fn LIL__lerp(var.f32 a; var.f32 b; var.f32 t) => f32
	{
		return a + (t * (b - a));
	}
	
	fn LIL__lerpPoints(var.@pos2d a; var.@pos2d b; var.f32 t) => @pos2d
	{
		var ret: @pos2d {
			x: LIL__lerp(a.x, b.x, t);
			y: LIL__lerp(a.y, b.y, t)
		};
		return ret;
	}

	fn LIL__evalQuadCurve(var.@pos2d fromPoint; var.@pos2d controlPoint; var.@pos2d toPoint; var.f32 t) => @pos2d
	{
		var.@pos2d q0: @pos2d { x: LIL__lerp(fromPoint.x, controlPoint.x, t); y: LIL__lerp(fromPoint.y, controlPoint.y, t) };
		var.@pos2d q1: @pos2d { x: LIL__lerp(controlPoint.x, toPoint.x, t); y: LIL__lerp(controlPoint.y, toPoint.y, t) };
		var.@pos2d r: @pos2d { x: LIL__lerp(q0.x, q1.x, t); y: LIL__lerp(q0.y, q1.y, t) };
		return r;
	}

	fn LIL__evalCubicCurve(var.@pos2d fromPoint; var.@pos2d controlPoint1; var.@pos2d controlPoint2; var.@pos2d toPoint; var.f32 t) => @pos2d
	{
		var a: @pos2d { x: LIL__lerp(fromPoint.x, controlPoint1.x, t); y: LIL__lerp(fromPoint.y, controlPoint1.y, t) };
		var b: @pos2d { x: LIL__lerp(controlPoint1.x, controlPoint2.x, t); y: LIL__lerp(controlPoint1.y, controlPoint2.y, t) };
		var c: @pos2d { x: LIL__lerp(controlPoint2.x, toPoint.x, t); y: LIL__lerp(controlPoint2.y, toPoint.y, t) };
		var d: @pos2d { x: LIL__lerp(a.x, b.x, t); y: LIL__lerp(a.y, b.y, t) };
		var e: @pos2d { x: LIL__lerp(b.x, c.x, t); y: LIL__lerp(b.y, c.y, t) };
		var r: @pos2d { x: LIL__lerp(d.x, e.x, t); y: LIL__lerp(d.y, e.y, t) };
		return r;
	}
}
