const DEBUG: false;
const DEBUG_SHAPE_VERTICES: false;

#snippet entityTypesSize { 10 };
#snippet namesSize { 32 };
#snippet selectionSize { 32 };
#snippet entitiesSize { 2048 };
#snippet componentsSize { 32 };
#snippet shapesSize { 32 };

fn onUpdate(var.f64 deltaTime) extern;
fn LIL__setWindowBgColor(var.f32 red; var.f32 green; var.f32 blue; var.f32 alpha) extern;
fn LIL__loadTexture(var.cstr path) extern;

#import "libtess2.lil";

#export {
    #needs "cstd.lil";
	#needs "events.lil";
	#needs "msg.lil";
    #needs "string.lil";

    //default entity types:
    //0: @container
    //1: @image
    //2: @sprite
	//3: @shape2d
    var.@app app: @app { selectables: []; entityCount: 0; typeCount: 4 };

    class @size {
        var.f64 width;
        var.f64 height;
    };
    class @rgb {
        var.f32 red;
        var.f32 green;
        var.f32 blue;
        var.f32 alpha;
    };
    class @vertex {
        var.f32 x;
        var.f32 y;
        var.@rgb color;
        var.f32 textureX;
        var.f32 textureY;
    };
    class @selectable {
        var.i64 nameId;
        var.i64 parentId;
        var.i64 typeId;
        var.i64 componentId;
        var.i64 resourceId;
		var.i64 actionId;
    };
    class @pos2d {
        var.f32 x;
        var.f32 y;
    };
    class @pos {
        var.f32 x;
        var.f32 y;
        var.f32 z;
    };
    class @box2d {
        var.f32 width;
        var.f32 height;
        var.@rgb bgColor;
    };
    class @img {
        var.f32 width;
        var.f32 height;
		var.f32 textureWidth;
		var.f32 textureHeight;
		var.bool useClip;
    };
    class @resource {
        var.[1024 x i8] path;
        var.ptr(any)|null data;
    };
    class @vel
    {
        var.f32 x: 0f32;
        var.f32 y: 0f32;
        var.f32 z: 0f32;
    };
    class @collider
    {
        var.f32 width;
        var.f32 height;
        var.f32 depth;
        var.f32 x;
        var.f32 y;
        var.f32 z;
    };
	enum.i32 ShapeType {
		moveTo,
		lineTo
	};
	class @shapeItem {
		var.ShapeType ty;
		var.f32 x: 0;
		var.f32 y: 0;
		var.f32 x2: 0;
		var.f32 y2: 0;
	};
	class @shapeData {
        var.f32 width;
        var.f32 height;
        var.f32 x;
        var.f32 y;
        var.f32 z;
		var.[#paste shapesSize x @shapeItem] items: [];
		var.i64 size: 0;
        var.@rgb bgColor;
	};
    class @element {
        var.i64 id: 0;
        
        vvar.@selectable selectable;
		vvar.ptr(any)|null action;
        
        fn getSelectable => @selectable {
            return app.selectables[@self.id];
        }
        fn getSelectablePointer => ptr(@selectable) {
            return pointerTo app.selectables[@self.id];
        }
        fn getName => cstr {
            var selectable: @self.selectable;
            return app.getName(selectable.nameId);
        }

		fn getAction => ptr(any)|null {
			var actionId: app.selectables[@self.id].actionId;
			if actionId >= 0 {
				return app.actions[actionId].ptr;
			} else {
				return null;
			}
		}
		fn setAction(var.ptr(any) ptr) {
			var existingAction: @self.getAction();
			if existingAction => null {
				var actionId: app.newActionId();
				app.selectables[@self.id].actionId: actionId;
				app.actions[actionId]: @action {
					elementId: @self.id;
					ptr: ptr;
				};
			}
		}
    };
    class @sel {
        var.[#paste selectionSize x @element] items: [];
        var.i64 size: 0;
    };
	class @action
	{
		var.i64 elementId;
		var.ptr(any) ptr;
	}
    class @container
    {
        //this class MUST only be an i64
        //do not add any more vars
        #expand var.@element super: @element { };

        //public interface
        vvar.i64 componentId;
        vvar.f32 width;
        vvar.f32 height;
        vvar.@rgb background;
        vvar.f32 x;
        vvar.f32 y;
        vvar.f32 z;
        vvar.@vel velocity;
        
        fn getComponentId => i64 {
            return app.selectables[@self.id].componentId;
        }
        
        fn initialize(var.cstr name; var.i64 parentId: 0) => i64 {
            var componentId: app.newBox();
			var id: app.newElement(name, parentId, 0, componentId);
			@self.id: id;
            return id;
        }

        fn setWidth(var.f32 value) {
            app.box2ds[@self.componentId].width: value;
            app.getCollider(@self.id).width: value;
        };
        fn getWidth {
            return app.box2ds[@self.componentId].width;
        };
        fn setHeight(var.f32 value) {
            app.box2ds[@self.componentId].height: value;
            app.getCollider(@self.id).height: value;
        };
        fn getHeight {
            return app.box2ds[@self.componentId].height;
        };
        fn setBackground(var.@rgb value) {
            app.box2ds[@self.componentId].bgColor: value;
        };
        fn getBackground {
            return app.box2ds[@self.componentId].bgColor;
        };
        fn getBackgroundPointer {
            return pointerTo app.box2ds[@self.componentId].bgColor;
        };
        fn setX(var.f32 value) {
            app.boxPositions[@self.componentId].x: value;
            app.colliders[@self.id].x: value;
        }
        fn getX() => f32 {
            return app.boxPositions[@self.componentId].x;
        };
        fn setY(var.f32 value) {
            app.boxPositions[@self.componentId].y: value;
            app.colliders[@self.id].y: value;
        };
        fn getY() => f32 {
            return app.boxPositions[@self.componentId].y;
        };
        fn setZ(var.f32 value) {
            app.boxPositions[@self.componentId].z: value;
            app.colliders[@self.id].z: value;
        };
        fn getZ() => f32 {
            return app.boxPositions[@self.componentId].z;
        };
        fn setVelocity(var.@vel value) {
            app.boxVelocities[@self.componentId]: value;
        };
        fn getVelocity() => @vel {
            return app.boxVelocities[@self.componentId];
        }
        fn getVelocityPointer() => ptr(@vel) {
            return pointerTo app.boxVelocities[@self.componentId];
        }
    };

    class @image {
        //this class MUST only be an i64
        //do not add any more vars
        #expand var.@element super: @element { };

        //public interface
        vvar.i64 componentId;
        vvar.f32 width;
        vvar.f32 height;
        vvar.f32 x;
        vvar.f32 y;
        vvar.f32 z;
        vvar.@vel velocity;
        //fixme: should be =>cstr
        #resource vvar.ptr(@string)=>ptr(i8) src;

        fn getComponentId => i64 {
            return app.selectables[@self.id].componentId;
        }

        fn initialize(var.cstr name; var.i64 parentId: 0) => i64 {
			#if DEBUG {
				puts `created image!`;
			}
            var componentId: app.newImg();
            @self.id: app.newElement(name, parentId, 1, componentId);
            return @self.id;
        }

        fn setWidth(var.f32 value) {
            app.imgs[@self.componentId].width: value;
            app.getCollider(@self.id).width: value;
        };
        fn getWidth {
            return app.imgs[@self.componentId].width;
        };
        fn setHeight(var.f32 value) {
            app.imgs[@self.componentId].height: value;
            app.getCollider(@self.id).height: value;
        };
        fn getHeight {
            return app.imgs[@self.componentId].height;
        };
        fn setX(var.f32 value) {
            app.imgPositions[@self.componentId].x: value;
            app.colliders[@self.id].x: value;
        }
        fn getX() => f32 {
            return app.imgPositions[@self.componentId].x;
        };
        fn setY(var.f32 value) {
            app.imgPositions[@self.componentId].y: value;
            app.colliders[@self.id].y: value;
        };
        fn getY() => f32 {
            return app.imgPositions[@self.componentId].y;
        };
        fn setZ(var.f32 value) {
            app.imgPositions[@self.componentId].z: value;
            app.colliders[@self.id].z: value;
        };
        fn getZ() => f32 {
            return app.imgPositions[@self.componentId].z;
        };
        fn setVelocity(var.@vel value) {
            app.imgVelocities[@self.componentId]: value;
        };
        fn getVelocity() => @vel {
            return app.imgVelocities[@self.componentId];
        }
        fn getVelocityPointer() => ptr(@vel) {
            return pointerTo app.imgVelocities[@self.componentId];
        }

        fn getSrc() => cstr {
            return pointerTo(app.resources[@self.id].path) => ptr(i8);
        }
        fn setSrc(var.ptr(@string) value) {
            memcpy(@self.src, value.cstr(), value.length);
            app.newResource(@self.id);
        }

		fn load(var.ptr(@string) value) {
            @self.setSrc(value);
			LIL__loadTexture(value.cstr());
		}
    };
    
    class @sprite {
        //this class MUST only be an i64
        //do not add any more vars
        #expand var.@image super: @image { };
        
        vvar.f32 clipX;
        vvar.f32 clipY;
        
        fn initialize(var.cstr name; var.i64 parentId: 0) => i64 {
			#if DEBUG {
				puts `created sprite!`;
			}
            var componentId: app.newImg();
            @self.id: app.newElement(name, parentId, 2, componentId);
			app.imgs[componentId].useClip: true;
            return @self.id;
        }
        
        fn setClipX(var.f32 value) {
            app.imgClips[@self.componentId].x: value;
        }
        fn getClipX() => f32 {
            return app.imgClips[@self.componentId].x;
        };
        fn setClipY(var.f32 value) {
            app.imgClips[@self.componentId].y: value;
        };
        fn getClipY() => f32 {
            return app.imgClips[@self.componentId].y;
        };
    }
	
	class @shape2d {
        //this class MUST only be an i64
        //do not add any more vars
        #expand var.@element super: @element { };
		
        //public interface
        vvar.i64 componentId;
        vvar.f32 width;
        vvar.f32 height;
        vvar.f32 x;
        vvar.f32 y;
        vvar.f32 z;
        vvar.@rgb background;

        fn getComponentId => i64 {
            return app.selectables[@self.id].componentId;
        }

        fn initialize(var.cstr name; var.i64 parentId: 0) => i64 {
			#if DEBUG {
				puts `created shape!`;
			}
            var componentId: app.newShape();
            @self.id: app.newElement(name, parentId, 3, componentId);
            return @self.id;
        }

        fn setWidth(var.f32 value) {
            app.shapes[@self.componentId].width: value;
        };
        fn getWidth {
            return app.shapes[@self.componentId].width;
        };
        fn setHeight(var.f32 value) {
            app.shapes[@self.componentId].height: value;
        };
        fn getHeight {
            return app.shapes[@self.componentId].height;
        };
        fn setX(var.f32 value) {
            app.shapes[@self.componentId].x: value;
        }
        fn getX() => f32 {
            return app.shapes[@self.componentId].x;
        };
        fn setY(var.f32 value) {
            app.shapes[@self.componentId].y: value;
        };
        fn getY() => f32 {
            return app.shapes[@self.componentId].y;
        };
        fn setZ(var.f32 value) {
            app.shapes[@self.componentId].z: value;
        };
        fn getZ() => f32 {
            return app.shapes[@self.componentId].z;
        };
        fn setBackground(var.@rgb value) {
            app.shapes[@self.componentId].bgColor: value;
        };
        fn getBackground {
            return app.shapes[@self.componentId].bgColor;
        };
        fn getBackgroundPointer {
            return pointerTo app.shapes[@self.componentId].bgColor;
        };
		
		fn moveTo(var.f32 x; var.f32 y) {
			var shape: pointerTo app.shapes[@self.componentId];
			var size: shape.size;
			var newItem: @shapeItem {
				ty: ShapeType.moveTo;
				x: x;
				y: y;
			};
			shape.items[size]: newItem;
			shape.size +: 1;
			#if DEBUG {
				printf(`created moveTo with x:%f and y:%f\n`, x, y);
			}
		}
		fn lineTo(var.f32 x; var.f32 y) {
			var shape: pointerTo app.shapes[@self.componentId];
			var size: shape.size;
			var newItem: @shapeItem {
				ty: ShapeType.lineTo;
				x: x;
				y: y;
			};
			shape.items[size]: newItem;
			shape.size +: 1;
			#if DEBUG {
				printf(`created lineTo with x:%f and y:%f\n`, x, y);
			}
		}
	}
	
	fn LIL__mouseClickListener(var.ptr(any) data) {
		var.ptr(@mouseEvent) event: data;
		var mouseX: event.x => f32;
		var mouseY: event.y => f32;
		#if DEBUG {
			printf(`mouse listener: x:%lf y:%lf\n`, mouseX, mouseY);	
		}
		for (var.i64 i: 0; i<app.actionCount; i +: 1) {
			var action: app.actions[i];
			var elem: app.selectables[action.elementId];
			var componentId: elem.componentId;
			var.bool result: false;
			if elem.typeId = 0 {
				var pos: app.boxPositions[componentId];
				var box: app.box2ds[componentId];
				result:
					(mouseX >= pos.x) AND (mouseX < (pos.x + box.width))
					AND (mouseY >= pos.y) AND (mouseY < (pos.y + box.height))
				;
			} else if ((elem.typeId = 1) OR (elem.typeId = 2)) {
				var pos: app.imgPositions[componentId];
				var img: app.imgs[componentId];
				var width: img.width;
				var height: img.height;
				if width = 0 { width: img.textureWidth }
				if height = 0 { height: img.textureHeight }
				result:
					(mouseX >= pos.x) AND (mouseX < (pos.x + width))
					AND (mouseY >= pos.y) AND (mouseY < (pos.y + height))
				;
			}
			if result {
				//FIXME: conversion from any ptr to fn pointer should be implicit
				var.ptr(fn(ptr(any))) callback: action.ptr => ptr(fn(ptr(any)));
				callback(data);
			}
		}
	}

    class @app {
        var.[#paste entitiesSize x @selectable] selectables: [];
        var.i64 entityCount: 0;
        //boxes
        var.[#paste entitiesSize x @pos] boxPositions: [];
        var.[#paste entitiesSize x @vel] boxVelocities: [];
        var.[#paste entitiesSize x @box2d] box2ds: [];
        var.i64 boxCount: 0;
        //imgs
        var.[#paste entitiesSize x @pos] imgPositions: [];
        var.[#paste entitiesSize x @vel] imgVelocities: [];
        var.[#paste entitiesSize x @pos2d] imgClips: [];
        var.[#paste entitiesSize x @img] imgs: [];
        var.i64 imgCount: 0;
		//shapes
		var.[#paste entitiesSize x @shapeData] shapes: [];
        var.i64 shapesCount: 0;
		//colliders
        var.[#paste entitiesSize x i64] colliderIds: [];
        var.[#paste componentsSize x @collider] colliders: [];
        var.[#paste namesSize x cstr] names: [];
        var.i64 nameCount: 0;
        var.i64 typeCount: 0;
		//resources
        var.[#paste entitiesSize x i64] resourceIds: [];
        var.[#paste entitiesSize x @resource] resources: [];
        var.i64 resourceCount: 0;
		//actions
		var.[#paste entitiesSize x @action] actions: [];
		var.i64 actionCount: 0;
		
		fn initialize {
            //get root's background color
			//fixme: use selection system instead of hardcoded to 0
            var bgColor: app.box2ds[0].bgColor;
            LIL__setWindowBgColor(bgColor.red, bgColor.green, bgColor.blue, bgColor.alpha);
			//install the mouse listener
			msgSub(`onClick`, LIL__mouseClickListener);
		};

        fn newEntity => i64 {
            #if DEBUG {
                puts `Creating new entity`;
            }
            var currentCount: @self.entityCount;
            @self.entityCount +: 1;
            return currentCount;
        };
        fn newType => i64 {
            #if DEBUG {
                puts `Creating new type`;
            }
            var currentCount: @self.typeCount;
            @self.typeCount +: 1;
            return currentCount;
        };
        fn registerName(var.cstr name){
            #if DEBUG {
                puts `Register name`;
            }
            var.bool found: false;
            var.i64 existingId: 0;
            #if DEBUG {
                printf(`Name count %li\n`, @self.nameCount);
            }
            for (var.i64 i:0; i<@self.nameCount; i+:1) {
                #if DEBUG {
                    printf(`Checking id %li\n`, i);
                }
                if(strcmp(name, @self.names[i]) = 0i32) {
                    found: true;
                    existingId: i;
                    //break;
                }
            }
            if found {
                return existingId;
            } else {
                var currentCount: @self.nameCount;
                @self.names[currentCount]: name;
                @self.nameCount +: 1;
                return currentCount;
            }
        };
        fn getName(var.i64 id){
            return @self.names[id];
        };
        fn selectByName(var.i64 parentId; var.i64 nameId)=>@sel {
            var ret: @sel { };
            for(var.i64 i: 0; i<@self.entityCount; i+:1) {
                var item: pointerTo @self.selectables[i];
                if item.parentId = parentId {
                    if item.nameId = nameId {
                        ret.items[ret.size]: @element { id: i };
                        ret.size +: 1;
                    }
                }
            }
            return ret;
        };
        fn setSelectable(var.i64 id; var.@selectable value) {
            #if DEBUG {
                printf(`Setting selectable with name %s for id %li with type %li\n`, @self.getName(value.nameId), id, value.typeId);
            }
            @self.selectables[id]: value;
        };
        fn newElement(var.cstr name; var.i64 parentId: 0; var.i64 typeId: 0; var.i64 componentId: 0)=>i64 {
            #if DEBUG {
                puts `Creating new element`;
            }
            var.i64 id: @self.newEntity();
            var.i64 nameId: @self.registerName(name);
            @self.setSelectable(id, @selectable {
                nameId: nameId;
                parentId: parentId;
                typeId: typeId;
                componentId: componentId;
				resourceId: (0-1);
				actionId: (0-1);
            });
            return id;
        };
        fn newBox => i64 {
            var currentCount: @self.boxCount;
            @self.boxCount +: 1;
            return currentCount;
        };
        fn newImg => i64 {
            var currentCount: @self.imgCount;
            @self.imgCount +: 1;
            return currentCount;
        };
        fn newShape => i64 {
            var currentCount: @self.shapesCount;
            @self.shapesCount +: 1;
            return currentCount;
        };
        fn setCollider(var.i64 id; var.@collider value) {
            var.i64 colliderId: @self.colliderIds[id];
            @self.colliders[colliderId]: value;
        };
        fn getCollider(var.i64 id) => ptr(@collider) {
            var.i64 colliderId: @self.colliderIds[id];
            return pointerTo @self.colliders[colliderId];
        };
        fn newResource(var.i64 id) {
            @self.resourceIds[@self.resourceCount]: id;
            @self.resourceCount +: 1;
        }
		fn newActionId => i64 {
            #if DEBUG {
                puts `Creating new action id`;
            }
            var currentCount: @self.actionCount;
            @self.actionCount +: 1;
            return currentCount;
		}
    };

    fn LIL__nameToNameId(var.cstr name) => i64 {
        return app.registerName(name);
    };

    fn LIL__selectByName(var.i64 nameId; var.i64 parentId) => @sel {
        var ret: @sel { };
        for(var.i64 i:0; i<app.entityCount; i+:1){
            var selectable: app.selectables[i];
            if (selectable.parentId = parentId) {
                if(selectable.nameId = nameId){
                    ret.items[ret.size]: @element { id: i };
                    ret.size +: 1;
                }
            }
        }
        return ret;
    };
    
    fn LIL__getResourceCount => i64 {
        return app.resourceCount;
    }
    
    fn LIL__getResorceById(var.i64 id) => ptr(@resource) {
        var resId: app.resourceIds[id];
        return pointerTo app.resources[resId];
    }
    
    fn LIL__movementSystem(var.f64 deltaTime) {
        var.f64 dt: deltaTime * 60;
        for (var.i64 i:0; i<app.boxCount; i+:1) {
            app.boxPositions[i].x +: ((app.boxVelocities[i].x => f64) * dt) => f32;
            app.boxPositions[i].y +: ((app.boxVelocities[i].y => f64) * dt) => f32;
            app.boxPositions[i].z +: ((app.boxVelocities[i].z => f64) * dt) => f32;
        }
        for (var.i64 i:0; i<app.imgCount; i+:1) {
            app.imgPositions[i].x +: ((app.imgVelocities[i].x => f64) * dt) => f32;
            app.imgPositions[i].y +: ((app.imgVelocities[i].y => f64) * dt) => f32;
            app.imgPositions[i].z +: ((app.imgVelocities[i].z => f64) * dt) => f32;
        }
    };

    fn LIL__runSystems(var.f64 deltaTime) {
        LIL__movementSystem(deltaTime);
    };

    fn LIL__nextFrame(var.ptr(any) vertexBuffer; var.ptr(i64) vertexCount; var.f64 deltaTime) {
        #if #getConfig(onUpdateFn) {
            onUpdate(deltaTime);
        }
        LIL__runSystems(deltaTime);
    };
	
	fn LIL__setTextureSize(var.i64 imgId; var.f32 width; var.f32 height) {
		app.imgs[imgId].textureWidth: width;
		app.imgs[imgId].textureHeight: height;
	};
    
    fn LIL__makeBoxVertices(var.ptr(any) vertexBuffer; var.ptr(i64) vertexCount) {

        var.[1000 x @vertex] vertices: [];
        for (var.i64 i:0; i<app.boxCount; i+:1) {

            var box: app.box2ds[i];
            var pos: app.boxPositions[i];
            var color: box.bgColor;

            var.i64 triIdx: i*6;

            vertices[triIdx]: @vertex {
                x: pos.x + box.width;
                y: pos.y;
                color: color;
                textureX: 1f32;
                textureY: 1f32;
            };

            vertices[triIdx+1]: @vertex {
                x: pos.x;
                y: pos.y;
                color: color;
                textureX: 0f32;
                textureY: 1f32;
            };

            vertices[triIdx+2]: @vertex {
                x: pos.x;
                y: pos.y + box.height;
                color: color;
                textureX: 0f32;
                textureY: 0f32;
            };


            vertices[triIdx+3]: @vertex {
                x: pos.x + box.width;
                y: pos.y;
                color: color;
                textureX: 1f32;
                textureY: 1f32;
            };

            vertices[triIdx+4]: @vertex {
                x: pos.x;
                y: pos.y + box.height;
                color: color;
                textureX: 0f32;
                textureY: 0f32;
            };

            vertices[triIdx+5]: @vertex {
                x: pos.x + box.width;
                y: pos.y + box.height;
                color: color;
                textureX: 1f32;
                textureY: 0f32;
            };
        }

        var.i64 bufferSize: (sizeOf(type @vertex) * 6 * app.boxCount);
        memcpy (vertexBuffer, pointerTo(vertices), bufferSize);
        vertexCount: app.boxCount * 6;
    }
    
    fn LIL__makeTextureVertices(var.ptr(any) vertexBuffer; var.ptr(i64) vertexCount) {
        var.[1000 x @vertex] vertices: [];
		var color: #F00;
        for (var.i64 i:0; i<app.imgCount; i+:1) {

            var img: app.imgs[i];
            var pos: app.imgPositions[i];
            var clip: app.imgClips[i];
            var.i64 triIdx: i*6;
			
			var.f32 minX;
			var.f32 maxX;
			var.f32 minY;
			var.f32 maxY;
			
			var.f32 width: img.width;
			var.f32 height: img.height;
			if width = 0 {
				width: img.textureWidth;
			}
			if height = 0 {
				height: img.textureHeight;
			}
			
			
			if img.useClip {
				minX: clip.x / img.textureWidth;
				maxX: (clip.x + width) / img.textureWidth;
				minY: clip.y / img.textureHeight;
				maxY: (clip.y + height) / img.textureHeight;
			} else {
				minX: 0;
				maxX: 1;
				minY: 0;
				maxY: 1;
			}
            
            vertices[triIdx]: @vertex {
                x: pos.x + width;
                y: pos.y;
                color: color;
                textureX: maxX;
                textureY: maxY;
            };

            vertices[triIdx+1]: @vertex {
                x: pos.x;
                y: pos.y;
                color: color;
                textureX: minX;
                textureY: maxY;
            };

            vertices[triIdx+2]: @vertex {
                x: pos.x;
                y: pos.y + height;
                color: color;
                textureX: minX;
                textureY: minY;
            };


            vertices[triIdx+3]: @vertex {
                x: pos.x + width;
                y: pos.y;
                color: color;
                textureX: maxX;
                textureY: maxY;
            };

            vertices[triIdx+4]: @vertex {
                x: pos.x;
                y: pos.y + height;
                color: color;
                textureX: minX;
                textureY: minY;
            };

            vertices[triIdx+5]: @vertex {
                x: pos.x + width;
                y: pos.y + height;
                color: color;
                textureX: maxX;
                textureY: minY;
            };
        }

        var.i64 bufferSize: (sizeOf(type @vertex) * 6 * app.imgCount);
        memcpy (vertexBuffer, pointerTo(vertices), bufferSize);
        vertexCount: app.imgCount * 6;
    }

	fn LIL__makeShapeVertices(var.ptr(any) vertexBuffer; var.ptr(i64) vertexCount; var.ptr(any) indexBuffer; var.ptr(i64) indexCount) {
		var.[1000 x @pos2d] subpaths: [];
		var.[300 x i64] subpathIndices: [];
		var.i64 pathElemsCount: 0;
		var.i64 subpathCount: 0;

		var.[1000 x @vertex] theVertices: [];
		var.[1000 x i32] theIndices: [];

		var.ptr(@TESStesselator) tess: tessNewTess(null);
		
		var.i64 vtxCount: 0;
		var.i64 idxCount: 0;

		for (var.i64 i:0; i<app.shapesCount; i+:1) {
			#if DEBUG_SHAPE_VERTICES {
				printf(`tessellating shape %li\n`, i);
			}
			pathElemsCount: 0;
			subpathCount: 0;
			
			var shape: pointerTo app.shapes[i];
			for (var.i64 j:0; j<shape.size; j+:1) {
				var shapeItem: shape.items[j];
				#if DEBUG_SHAPE_VERTICES {
					printf(`shape item %li has type %i\n`, j, shapeItem.ty);
				}
				if shapeItem.ty = ShapeType.moveTo
				{
					subpathIndices[subpathCount]: pathElemsCount;
					subpathCount +: 1;

					subpaths[pathElemsCount]: @pos2d {
						x: shapeItem.x;
						y: shapeItem.y;
					};
					pathElemsCount +: 1;
				}
				else if shapeItem.ty = ShapeType.lineTo
				{
					subpaths[pathElemsCount]: @pos2d {
						x: shapeItem.x;
						y: shapeItem.y;
					};
					pathElemsCount +: 1;
				}
			}

			for (var.i64 j:0; j<subpathCount; j+:1) {
				var.i64 from: subpathIndices[j];
				var.i64 to;
				if j < (subpathCount - 1) {
					to: subpathIndices[j+1];
				} else {
					to: pathElemsCount;
				}
				tessAddContour(
					tess: tess;
					size: 2;
					vertices: (pointerTo(subpaths) => ptr(@pos2d)) + from;
					stride: sizeOf(type @pos2d) => i32;
					numVertices: (to - from) => i32
				);
			}
		
			var tessResult: tessTesselate(
				tess: tess;
				windingRule: TESSwindingRule.odd;
				elementType: TESSelementType.polygons;
				polySize: 3;
				vertexSize: 2
			);
			#if DEBUG_SHAPE_VERTICES {
				printf(`tessellation result is %i\n`, tessResult);
			}
		
			var.i64 tessVertexCount: tessGetVertexCount(tess);
			var.ptr(f32) tessVertices: tessGetVertices(tess);
			var.i64 tessElemCount: tessGetElementCount(tess);
			var.ptr(i32) tessIndices: tessGetElements(tess);

			for (var.i64 k:0; k<tessVertexCount; k+:1) {
				theVertices[vtxCount + k]: @vertex {
					x: valueOf(tessVertices + (k*2)) + shape.x;
					y: valueOf(tessVertices + ((k*2)+1)) + shape.y;
	                color: shape.bgColor;
	                textureX: 0;
	                textureY: 0;
				};
			}
			
			var.i64 tessIndexCount: tessElemCount * 3;
			#if DEBUG_SHAPE_VERTICES {
				printf(`copying %li indices to %li\n`, tessIndexCount, idxCount);
			}
			for (var.i64 k:0; k<tessIndexCount; k+:1) {
				theIndices[idxCount + k]: valueOf(tessIndices + k) + vtxCount;
			}
			vtxCount +: tessVertexCount;
			idxCount +: tessIndexCount;
		}

		tessDeleteTess(tess);
		
		#if DEBUG_SHAPE_VERTICES {
			puts `vertices:`;
			for (var.i64 i:0; i<vtxCount; i+:1) {
				var vtx: theVertices[i];
				printf(`%f %f ,`, vtx.x, vtx.y);
			}
			printf(`\n`);

			puts `indices:`;
			for (var.i64 i:0; i<idxCount; i+:1) {
				var idx: theIndices[i];
				printf(`%li, `, idx);
			}
			printf(`\n`);
		}

		var.i64 bufferSize: (sizeOf(type @vertex) * vtxCount);
		#if DEBUG_SHAPE_VERTICES {
			printf(`copying %li vertices to buffer\n`, vtxCount);
		}
    	memcpy (vertexBuffer, pointerTo(theVertices), bufferSize);
		vertexCount: vtxCount;
		indexCount: idxCount;
		memcpy (indexBuffer, pointerTo(theIndices), (sizeOf(type i32) * idxCount));
		#if DEBUG_SHAPE_VERTICES {
			printf(`copying %li indices to index buffer\n`, idxCount);
			puts `=====`;
		}
	}
}
